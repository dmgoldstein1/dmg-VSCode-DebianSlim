#!/bin/bash

# Generated by Copilot (GPT-4), 2025-08-30
# Description: This script builds the VS Code Debian Slim Docker image with a deterministic tag 
# based on the base image and dependencies. After building, it runs Docker Scout CVE and 
# recommendations analysis, saves logs, and prints a summary of vulnerability counts.

# Safety check: require bash (the script uses bash features like arrays and process substitution)
if [ -z "${BASH_VERSION:-}" ]; then
  echo "Error: This script must be run with bash, not sh. Use: bash $0 [args] or make it executable and run ./$(basename "$0")" >&2
  exit 2
fi

# --- Ensure /logs directory exists ---
LOGS_DIR="logs"
mkdir -p "$LOGS_DIR"

# --- Signal handling for clean shutdown ---
cleanup() {
  echo -e "\nReceived interrupt signal. Cleaning up..."
  
  # Kill Docker build process if it exists
  if [ -n "${DOCKER_BUILD_PID:-}" ] && kill -0 "$DOCKER_BUILD_PID" 2>/dev/null; then
    echo "Killing Docker build process: $DOCKER_BUILD_PID"
    kill -TERM "$DOCKER_BUILD_PID" 2>/dev/null || true
    sleep 2
    kill -KILL "$DOCKER_BUILD_PID" 2>/dev/null || true
    wait "$DOCKER_BUILD_PID" 2>/dev/null || true
  fi
  
  # Kill any other running Docker build processes
  local docker_pids
  docker_pids=$(pgrep -f "docker build" 2>/dev/null || true)
  if [ -n "$docker_pids" ]; then
    echo "Killing additional Docker build processes: $docker_pids"
    echo "$docker_pids" | xargs kill -TERM 2>/dev/null || true
    sleep 2
    echo "$docker_pids" | xargs kill -KILL 2>/dev/null || true
  fi
  
  # Kill background log monitoring process if it exists
  if [ -n "${LOG_PID:-}" ] && kill -0 "$LOG_PID" 2>/dev/null; then
    echo "Killing log monitoring process: $LOG_PID"
    kill -TERM "$LOG_PID" 2>/dev/null || true
    sleep 1
    kill -KILL "$LOG_PID" 2>/dev/null || true
    wait "$LOG_PID" 2>/dev/null || true
  fi
  
  # Stop and remove the container if it exists
  if [ -n "${CONTAINER_NAME:-}" ] && docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    echo "Stopping container $CONTAINER_NAME..."
    docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    docker rm "$CONTAINER_NAME" >/dev/null 2>&1 || true
  fi
  
  # Kill any other child processes
  local child_pids
  child_pids=$(jobs -p 2>/dev/null || true)
  if [ -n "$child_pids" ]; then
    echo "Killing child processes: $child_pids"
    echo "$child_pids" | xargs kill -TERM 2>/dev/null || true
    sleep 1
    echo "$child_pids" | xargs kill -KILL 2>/dev/null || true
  fi
  
  # Stop tee logger and remove FIFO if set
  if [ -n "${TEE_PID:-}" ] && kill -0 "$TEE_PID" 2>/dev/null; then
    echo "Stopping tee logger: $TEE_PID"
    kill -TERM "$TEE_PID" 2>/dev/null || true
    wait "$TEE_PID" 2>/dev/null || true
  fi
  if [ -n "${LOG_PIPE:-}" ]; then
    rm -f "$LOG_PIPE" 2>/dev/null || true
  fi
  
  echo "Cleanup complete. Exiting."
  exit 130  # Standard exit code for SIGINT
}

# Trap SIGINT (Ctrl+C) and SIGTERM
trap cleanup SIGINT SIGTERM

# Enable job control for proper signal handling
set -m

# --- Helper: Get unique log filename in /logs ---
get_unique_logfile() {
  local base="$1"
  local ext="$2"
  
  # Extract identifier from base name (string after last hyphen)
  local identifier
  identifier=${base##*-}
  
  # Create directory for this identifier
  local log_dir="$LOGS_DIR/$identifier"
  mkdir -p "$log_dir"
  
  # Create unique filename within the identifier directory
  local path="$log_dir/${base}${ext}"
  local n=1
  while [ -f "$path" ]; do
    path="$log_dir/${base}_$n${ext}"
    n=$((n+1))
  done
  echo "$path"
}

# --- Build log file for this run ---
BUILD_LOG_BASE="build-log-$(date +%s)"
BUILD_LOG_EXT=".log"
BUILD_LOG=$(get_unique_logfile "$BUILD_LOG_BASE" "$BUILD_LOG_EXT")

# Note: Verbose logging redirection will be set up after argument parsing
# Generated by Copilot (GPT-4)
# This script now supports passing an optional tunnel name as the first argument.
# This script builds the VS Code Debian Slim Docker image with a deterministic tag based on the base image and dependencies.
# After building, it runs Docker Scout CVE and recommendations analysis, saves logs, and prints a summary of vulnerability counts (critical, high, medium, low, unspecified) for the entire image (npm and system packages).
# Usage: ./build.sh [TunnelName] [--force-analysis] [--force-rebuild] [--logging] [--copilot-is-autonomous] [--git-user-name NAME] [--git-user-email EMAIL] [--use-yaml] [--test-mode] [--help] [--port PORT] [--image-name NAME] [--container-name NAME]
#   --logging: Enables verbose logging output for debugging and detailed progress.
#   --copilot-is-autonomous: Configures VS Code to auto-approve terminal commands for GitHub Copilot.
#   --git-user-name: Git user.name to pass into the container (exported as GIT_USER_NAME).
#   --git-user-email: Git user.email to pass into the container (exported as GIT_USER_EMAIL).
#   --use-yaml: Ignore other flags/args and load configuration from build_variables.yaml in this directory.
#   --test-mode: Build and start container, wait for tunnel connection, then auto-terminate.
#                Manual termination available with 'quit', 'exit', 'q', or Ctrl+C.
#   --help: Show this help message.
#   --port: Port to expose on host (default: auto-find free port starting at 8080).
#   --image-name: Docker image name (default: dmg-vs-code-debian-slim).
#   --container-name: Container name (default: based on tunnel name or vscode-server-tunnel).

# Parse arguments and (optionally) a YAML config file
# If --use-yaml is present, ignore all other flags/args and source values from build_variables.yaml

# Defaults
TUNNEL_NAME_ARG=""
FORCE_ANALYSIS=false
FORCE_REBUILD=false
VERBOSE_LOGGING=false
COPILOT_AUTONOMOUS=false
GIT_USER_NAME=""
GIT_USER_EMAIL=""
GH_TOKEN="${GITHUB_TOKEN:-}"  # Inherit GITHUB_TOKEN from environment if available
AUTO_UPDATE_ON_START=""
UPDATE_CHECK_INTERVAL_SECONDS=""
APPROVAL_FILE=""
USE_YAML=false
TEST_MODE=false
YAML_FILE="build_variables.yaml"
HOST_PORT=""  # Empty means auto-find
IMAGE_NAME="dmg-vs-code-debian-slim"
CONTAINER_NAME=""  # Empty means use tunnel name or default

# Pre-scan to detect --use-yaml
for pre in "$@"; do
  [ "$pre" = "--use-yaml" ] && USE_YAML=true && break
done

parse_bool() {
  case "$1" in
    true|TRUE|True|1|yes|YES|y|Y) echo "true" ;;
    false|FALSE|False|0|no|NO|n|N|"") echo "false" ;;
    *) echo "$1" ;;
  esac
}

load_yaml_config() {
  local file="$1"
  if [ ! -f "$file" ]; then
    echo "Error: --use-yaml specified but $file not found." >&2
    exit 3
  fi
  # Simple YAML (key: value) parser; ignores comments and nested structures
  # Supported keys:
  #   tunnel_name, force_analysis, logging, copilot_is_autonomous,
  #   git_user_name, git_user_email, gh_token,
  #   auto_update_on_start, update_check_interval_seconds, approval_file, test_mode,
  #   port, image_name, container_name
  while IFS= read -r line; do
    # strip comments
    line="${line%%#*}"
    # trim
    line="$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')"
    [ -z "$line" ] && continue
    key="${line%%:*}"
    val="${line#*:}"
    key="$(echo "$key" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')"
    val="$(echo "$val" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')"
    # remove optional surrounding quotes
    val="$(echo "$val" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")"
    case "$key" in
      tunnel_name) TUNNEL_NAME_ARG="$val" ;;
      force_analysis) FORCE_ANALYSIS=$(parse_bool "$val") ;;
      force_rebuild) FORCE_REBUILD=$(parse_bool "$val") ;;
      logging) VERBOSE_LOGGING=$(parse_bool "$val") ;;
      copilot_is_autonomous) COPILOT_AUTONOMOUS=$(parse_bool "$val") ;;
      test_mode) TEST_MODE=$(parse_bool "$val") ;;
      git_user_name) GIT_USER_NAME="$val" ;;
      git_user_email) GIT_USER_EMAIL="$val" ;;
      gh_token) GH_TOKEN="$val" ;;
      auto_update_on_start) AUTO_UPDATE_ON_START="$val" ;;
      update_check_interval_seconds) UPDATE_CHECK_INTERVAL_SECONDS="$val" ;;
      approval_file) APPROVAL_FILE="$val" ;;
      port) HOST_PORT="$val" ;;
      image_name) IMAGE_NAME="$val" ;;
      container_name) CONTAINER_NAME="$val" ;;
      *)
        # unknown key ignored (forward compatibility)
        ;;
    esac
  done < "$file"
}

if [ "$USE_YAML" = "true" ]; then
  load_yaml_config "$YAML_FILE"
else
  # Flag parser (no YAML). Supports positional TunnelName and explicit flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --force-analysis|--force-rebuild|--logging|--copilot-is-autonomous|--test-mode|--use-yaml|--help|--)
        # Flags with no argument or handled elsewhere
        case "$1" in
          --force-analysis) FORCE_ANALYSIS=true ;;
          --force-rebuild) FORCE_REBUILD=true ;;
          --logging) VERBOSE_LOGGING=true ;;
          --copilot-is-autonomous) COPILOT_AUTONOMOUS=true ;;
          --test-mode) TEST_MODE=true ;;
          --use-yaml) USE_YAML=true; load_yaml_config "$YAML_FILE"; break ;;
          --help)
            echo "Usage: $0 [TunnelName] [OPTIONS]"
            echo ""
            echo "Options:"
            echo "    --force-analysis              Force re-run of Docker Scout analysis"
            echo "    --force-rebuild               Force rebuild of Docker image"
            echo "    --logging                     Enable verbose logging"
            echo "    --copilot-is-autonomous       Configure VS Code for autonomous Copilot"
            echo "    --git-user-name NAME          Git user name"
            echo "    --git-user-email EMAIL        Git user email"
            echo "    --gh-token TOKEN              GitHub token"
            echo "    --auto-update-on-start VAL    Auto update on start"
            echo "    --update-check-interval-seconds SEC  Update check interval"
            echo "    --approval-file FILE          Approval file path"
            echo "    --use-yaml                    Load config from build_variables.yaml"
            echo "    --test-mode                   Run in test mode"
            echo "    --port PORT                   Host port (default: auto-find)"
            echo "    --image-name NAME             Docker image name"
            echo "    --container-name NAME         Container name"
            echo "    --help                        Show this help message"
            echo ""
            echo "Examples:"
            echo "    $0 my-tunnel --logging --git-user-name 'John Doe' --git-user-email 'john@example.com'"
            echo "    $0 --use-yaml"
            echo "    $0 --port 3000 --image-name my-vscode --container-name my-container"
            exit 0 ;;
          --)
            shift; break ;;
        esac
        shift ;;
      --git-user-name|--git-user-email|--gh-token|--auto-update-on-start|--update-check-interval-seconds|--approval-file|--port|--image-name|--container-name)
        # Flags with arguments
        if [ $# -lt 2 ]; then
          echo "Error: Flag '$1' requires an argument." >&2
          exit 1
        fi
        case "$1" in
          --git-user-name) GIT_USER_NAME="$2" ;;
          --git-user-email) GIT_USER_EMAIL="$2" ;;
          --gh-token) GH_TOKEN="$2" ;;
          --auto-update-on-start) AUTO_UPDATE_ON_START="$2" ;;
          --update-check-interval-seconds) UPDATE_CHECK_INTERVAL_SECONDS="$2" ;;
          --approval-file) APPROVAL_FILE="$2" ;;
          --port) HOST_PORT="$2" ;;
          --image-name) IMAGE_NAME="$2" ;;
          --container-name) CONTAINER_NAME="$2" ;;
        esac
        shift 2 ;;
      -* )
        echo "Error: Flag '$1' is undefined." >&2
        exit 1 ;;
      *)
        # first non-flag token = tunnel name (if not set yet)
        if [ -z "$TUNNEL_NAME_ARG" ]; then
          TUNNEL_NAME_ARG="$1"
        fi
        shift ;;
    esac
  done
fi

if [ -n "$TUNNEL_NAME_ARG" ]; then
  echo "Tunnel name argument provided: $TUNNEL_NAME_ARG"
  # Validate: only numbers, lowercase letters, and underscores allowed
  if ! echo "$TUNNEL_NAME_ARG" | grep -Eq '^[a-z0-9_]+$'; then
    echo "Error: Tunnel name '$TUNNEL_NAME_ARG' is invalid. Only numbers, lowercase letters, and underscores are allowed. No capital letters or special characters permitted."
    exit 2
  fi
fi

if [ "$USE_YAML" = "true" ]; then
  echo "Loaded configuration from $YAML_FILE."
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "- force_analysis=$FORCE_ANALYSIS"
    echo "- force_rebuild=$FORCE_REBUILD"
    echo "- logging=$VERBOSE_LOGGING"
    echo "- copilot_is_autonomous=$COPILOT_AUTONOMOUS"
    echo "- tunnel_name=$TUNNEL_NAME_ARG"
  echo "- git_user_name set? $( [ -n "$GIT_USER_NAME" ] && echo yes || echo no )"
  echo "- git_user_email set? $( [ -n "$GIT_USER_EMAIL" ] && echo yes || echo no )"
  echo "- gh_token set? $( [ -n "$GH_TOKEN" ] && echo yes || echo no )"
    echo "- auto_update_on_start=$AUTO_UPDATE_ON_START"
    echo "- update_check_interval_seconds=$UPDATE_CHECK_INTERVAL_SECONDS"
    echo "- approval_file=$APPROVAL_FILE"
    echo "- port=$HOST_PORT"
    echo "- image_name=$IMAGE_NAME"
    echo "- container_name=$CONTAINER_NAME"
  fi
fi

# Validate git configuration (both name and email should be provided together)
if [[ -n "$GIT_USER_NAME" && -z "$GIT_USER_EMAIL" ]] || [[ -z "$GIT_USER_NAME" && -n "$GIT_USER_EMAIL" ]]; then
    echo "Error: Both git user name and email must be provided together" >&2
    exit 1
fi

# Check if Docker is running
if ! docker info >/dev/null 2>&1; then
    echo "Error: Docker is not running or not accessible" >&2
    exit 1
fi

# --- Set up verbose logging redirection after argument parsing ---
if [ "$VERBOSE_LOGGING" = "true" ]; then
  LOG_PIPE=$(mktemp -u)
  mkfifo "$LOG_PIPE"
  tee -a "$BUILD_LOG" < "$LOG_PIPE" &
  TEE_PID=$!
  exec > "$LOG_PIPE" 2>&1
  echo "[INFO] Verbose logging enabled. All output will be saved to $BUILD_LOG"
fi


DOCKERFILE=Dockerfile
# Use provided image name or default
if [ -z "$IMAGE_NAME" ]; then
  IMAGE_NAME="dmg-vs-code-debian-slim"
fi

# Extract the base image version (debian:stable-slim)
BASE_IMAGE=$(grep '^FROM' "$DOCKERFILE" | awk '{print $2}')

# Get the digest of the base image
BASE_DIGEST=$(docker pull "$BASE_IMAGE" | grep 'Digest:' | awk '{print $2}')

# Get all dependency lines (RUN, ADD, COPY)
DEPENDENCY_LINES=$(grep -E '^(RUN|ADD|COPY)' "$DOCKERFILE")

# Compute hash from base image + digest + dependency lines (cross-platform)
HASH_INPUT="$BASE_IMAGE@$BASE_DIGEST\n$DEPENDENCY_LINES"
if command -v sha256sum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | sha256sum | awk '{print $1}' | cut -c1-12)
elif command -v shasum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | shasum -a 256 | awk '{print $1}' | cut -c1-12)
else
  echo "Error: Neither sha256sum nor shasum found. Please install one of them." >&2
  exit 1
fi

FULL_TAG="$IMAGE_NAME:$TAG"

# --- Build the container if it does not exist or force rebuild is enabled ---
IMAGE_ALREADY_EXISTS=false
DOCKER_BUILD_LOG=$(get_unique_logfile "docker-build-$TAG" ".log")
if ! docker image inspect "$FULL_TAG" >/dev/null 2>&1 || [ "$FORCE_REBUILD" = "true" ]; then
  if [ "$FORCE_REBUILD" = "true" ] && docker image inspect "$FULL_TAG" >/dev/null 2>&1; then
    echo "Force rebuild enabled. Removing existing image $FULL_TAG..."
    docker rmi -f "$FULL_TAG" >/dev/null 2>&1 || true
    echo "Building container image $FULL_TAG..."
  else
    echo "Container image $FULL_TAG not found. Building..."
  fi
  
  # Run docker build in background to allow signal handling
  docker build -t "$FULL_TAG" -f "$DOCKERFILE" . > "$DOCKER_BUILD_LOG" 2>&1 &
  DOCKER_BUILD_PID=$!
  
  # Wait for docker build to complete, but allow interruption
  if wait "$DOCKER_BUILD_PID"; then
    echo "[INFO] Docker build completed successfully"
    if [ "$VERBOSE_LOGGING" = "true" ]; then
      echo "[INFO] Docker build log saved to $DOCKER_BUILD_LOG"
      echo "--- Last 20 lines of build log ---"
      tail -20 "$DOCKER_BUILD_LOG"
    fi
  else
    BUILD_EXIT_CODE=$?
    echo "[ERROR] Docker build failed with exit code $BUILD_EXIT_CODE"
    if [ "$VERBOSE_LOGGING" = "true" ]; then
      echo "--- Last 20 lines of build log ---"
      tail -20 "$DOCKER_BUILD_LOG"
    fi
    exit $BUILD_EXIT_CODE
  fi
else
  echo "Container image $FULL_TAG already exists."
  IMAGE_ALREADY_EXISTS=true
fi

# Portable timeout function
run_with_timeout() {
  local timeout_duration="$1"
  shift
  local cmd=("$@")
  
  # Run command in background
  "${cmd[@]}" &
  local cmd_pid=$!
  
  # Start timeout killer in background
  (
    sleep "$timeout_duration"
    if kill -0 "$cmd_pid" 2>/dev/null; then
      echo "Timeout reached, killing process $cmd_pid" >&2
      kill -TERM "$cmd_pid" 2>/dev/null || true
      sleep 2
      kill -KILL "$cmd_pid" 2>/dev/null || true
    fi
  ) &
  local killer_pid=$!
  
  # Wait for command to complete
  if wait "$cmd_pid"; then
    # Command completed successfully, kill the timeout killer
    kill "$killer_pid" 2>/dev/null || true
    return 0
  else
    local exit_code=$?
    # Command failed, kill the timeout killer
    kill "$killer_pid" 2>/dev/null || true
    return $exit_code
  fi
}

# --- Security Remediation Steps (skip if image already exists) ---
if [ "$IMAGE_ALREADY_EXISTS" = "false" ]; then
  # 1. Run npm audit fix in a temp container (if npm is present)
  NPM_AUDIT_LOG=$(get_unique_logfile "npm-audit-$TAG" ".log")
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Running npm audit fix in a temp container (if npm is present)..."
    # shellcheck disable=SC2016
    run_with_timeout 300 docker run --rm "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' | tee "$NPM_AUDIT_LOG" || true
    echo "[INFO] NPM audit log saved to $NPM_AUDIT_LOG"
  else
    # shellcheck disable=SC2016
    run_with_timeout 300 docker run --rm "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' > "$NPM_AUDIT_LOG" 2>&1 || true
  fi
  
  # 2. Run apt-get update/upgrade in a temp container (if apt is present)
  APT_UPGRADE_LOG=$(get_unique_logfile "apt-upgrade-$TAG" ".log")
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Running apt-get update/upgrade in a temp container (if apt is present)..."
    run_with_timeout 300 docker run --rm "$FULL_TAG" sh -c '\
      if command -v apt-get >/dev/null 2>&1; then \
        apt-get update && \
        apt-get upgrade -y || true; \
      fi' | tee "$APT_UPGRADE_LOG" || true
    echo "[INFO] Apt upgrade log saved to $APT_UPGRADE_LOG"
  else
    run_with_timeout 300 docker run --rm "$FULL_TAG" sh -c '\
      if command -v apt-get >/dev/null 2>&1; then \
        apt-get update >/dev/null 2>&1 && \
        apt-get upgrade -y >/dev/null 2>&1 || true; \
      fi' > "$APT_UPGRADE_LOG" 2>&1 || true
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Skipping security remediation steps (image already exists and analyzed)."
  fi
fi
# --- Rebuild image after remediation steps (optional: user may want to commit these changes in a Dockerfile for persistence) ---
# (Not rebuilding here, just analyzing the original build)


# --- Docker Scout Analysis (skip if image already exists and logs exist) ---
SCOUT_CVES_LOG_BASE="docker-scout-cves-$TAG"
SCOUT_RECOMMENDATIONS_LOG_BASE="docker-scout-recommendations-$TAG"
SCOUT_CVES_LOG_EXT=".log"
SCOUT_RECOMMENDATIONS_LOG_EXT=".log"
SCOUT_CVES_LOG=$(get_unique_logfile "$SCOUT_CVES_LOG_BASE" "$SCOUT_CVES_LOG_EXT")
SCOUT_RECOMMENDATIONS_LOG=$(get_unique_logfile "$SCOUT_RECOMMENDATIONS_LOG_BASE" "$SCOUT_RECOMMENDATIONS_LOG_EXT")

# If logs already exist and not forcing analysis, reuse the first matching log files
find_first_log() {
  local base="$1"
  local ext="$2"
  local first
  first=$(find "$LOGS_DIR" -name "${base}*${ext}" -type f 2>/dev/null | head -n1)
  echo "$first"
}

if [ "$IMAGE_ALREADY_EXISTS" = "true" ] && [ -n "$(find_first_log "$SCOUT_CVES_LOG_BASE" "$SCOUT_CVES_LOG_EXT")" ] && [ -n "$(find_first_log "$SCOUT_RECOMMENDATIONS_LOG_BASE" "$SCOUT_RECOMMENDATIONS_LOG_EXT")" ] && [ "$FORCE_ANALYSIS" = "false" ]; then
  SCOUT_CVES_LOG=$(find_first_log "$SCOUT_CVES_LOG_BASE" "$SCOUT_CVES_LOG_EXT")
  SCOUT_RECOMMENDATIONS_LOG=$(find_first_log "$SCOUT_RECOMMENDATIONS_LOG_BASE" "$SCOUT_RECOMMENDATIONS_LOG_EXT")
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Using existing Docker Scout analysis for $FULL_TAG (use --force-analysis to re-run)..."
    echo "CVEs log: $SCOUT_CVES_LOG"
    echo "Recommendations log: $SCOUT_RECOMMENDATIONS_LOG"
  fi
else
  # Check if Docker Scout is available
  if ! docker scout version >/dev/null 2>&1; then
    echo "Warning: Docker Scout not available. Skipping vulnerability analysis."
    echo "To install Docker Scout, visit: https://docs.docker.com/scout/"
    SCOUT_CVES_LOG=""
    SCOUT_RECOMMENDATIONS_LOG=""
  else
    if [ "$VERBOSE_LOGGING" = "true" ]; then
      echo "Running Docker Scout analysis for $FULL_TAG..."
      docker scout cves "$FULL_TAG" | tee "$SCOUT_CVES_LOG"
      docker scout recommendations "$FULL_TAG" | tee "$SCOUT_RECOMMENDATIONS_LOG"
    else
      echo "Running vulnerability analysis..."
      docker scout cves "$FULL_TAG" > "$SCOUT_CVES_LOG" 2>&1
      docker scout recommendations "$FULL_TAG" > "$SCOUT_RECOMMENDATIONS_LOG" 2>&1
    fi
  fi
fi

# --- Enhanced Vulnerability Summary ---
# For each tier, count total and how many have/don't have a public patch
if [ -n "$SCOUT_CVES_LOG" ] && [ -f "$SCOUT_CVES_LOG" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo -e "\nVulnerability summary for $FULL_TAG:" | tee -a "$SCOUT_CVES_LOG"
  else
    echo "Analyzing vulnerabilities..."
  fi

  # Parse the Docker Scout CVE output and count vulnerabilities by severity
  # Count vulnerabilities by severity level
  CRITICAL_COUNT=$(grep -c "CRITICAL" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0")
  HIGH_COUNT=$(grep -c "HIGH" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0") 
  MEDIUM_COUNT=$(grep -c "MEDIUM" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0")
  LOW_COUNT=$(grep -c "LOW" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0")
  UNSPECIFIED_COUNT=$(grep -c "UNSPECIFIED" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0")
  
  # Count fixable vulnerabilities (those with available patches)
  FIXABLE_COUNT=$(grep -c "Fixed version" "$SCOUT_CVES_LOG" 2>/dev/null || echo "0")
  
  echo "=== Vulnerability Summary for $FULL_TAG ==="
  echo "Critical:     $CRITICAL_COUNT"
  echo "High:         $HIGH_COUNT" 
  echo "Medium:       $MEDIUM_COUNT"
  echo "Low:          $LOW_COUNT"
  echo "Unspecified:  $UNSPECIFIED_COUNT"
  echo "Fixable:      $FIXABLE_COUNT"
  echo "============================================"
  
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Full CVE analysis saved to: $SCOUT_CVES_LOG"
    echo "Recommendations saved to: $SCOUT_RECOMMENDATIONS_LOG"
  fi
else
  echo "Warning: Docker Scout analysis not available. Skipping vulnerability summary."
  echo "To enable vulnerability analysis, install Docker Scout: https://docs.docker.com/scout/"
fi

# --- Copilot (GPT-4) generated: Launch container and display VS Code Tunnel token ---
# This section ensures the container is running and the user sees the tunnel auth code and link in the terminal output.


# Use a unique container name if tunnel name is provided, else default
if [ -n "$CONTAINER_NAME" ]; then
  # Use provided container name (from YAML or flag)
  :
elif [ -n "$TUNNEL_NAME_ARG" ]; then
  # Always use tunnel_name as container name if set
  CONTAINER_NAME="$TUNNEL_NAME_ARG"
else
  CONTAINER_NAME="vscode-server-tunnel"
fi

# Stop and remove any previous container with the same name
if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
  echo "Stopping and removing previous container $CONTAINER_NAME..."
  docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
  docker rm "$CONTAINER_NAME" >/dev/null 2>&1 || true
fi


# --- Copilot (GPT-4): Copy local VS Code settings.json into the container before tunnel starts ---
MAC_SETTINGS_JSON="$HOME/Library/Application Support/Code/User/settings.json"
CONTAINER_SETTINGS_DIR="/home/devuser/.config/Code/User"
CONTAINER_SETTINGS_JSON="$CONTAINER_SETTINGS_DIR/settings.json"




# Find a free host port starting at specified port or 8080
if [ -n "$HOST_PORT" ]; then
  START_PORT="$HOST_PORT"
else
  START_PORT=8080
fi

HOST_PORT="$START_PORT"
while lsof -iTCP:"$HOST_PORT" -sTCP:LISTEN >/dev/null 2>&1; do
  HOST_PORT=$((HOST_PORT+1))
done
if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "Using host port $HOST_PORT for container $CONTAINER_NAME (host:$HOST_PORT -> container:8080)"
fi

# --- Docker run log ---
DOCKER_RUN_LOG=$(get_unique_logfile "docker-run-$CONTAINER_NAME-$TAG" ".log")

echo "Launching VS Code Server container as $CONTAINER_NAME..."

# Build environment list for docker run
RUN_ENVS=( )
[ -n "$TUNNEL_NAME_ARG" ] && RUN_ENVS+=( -e "TUNNEL_NAME=$TUNNEL_NAME_ARG" )
[ -n "$GIT_USER_NAME" ] && RUN_ENVS+=( -e "GIT_USER_NAME=$GIT_USER_NAME" )
[ -n "$GIT_USER_EMAIL" ] && RUN_ENVS+=( -e "GIT_USER_EMAIL=$GIT_USER_EMAIL" )
[ -n "$GH_TOKEN" ] && RUN_ENVS+=( -e "GH_TOKEN=$GH_TOKEN" )
[ -n "$GITHUB_TOKEN" ] && RUN_ENVS+=( -e "GITHUB_TOKEN=$GITHUB_TOKEN" )
[ -n "$AUTO_UPDATE_ON_START" ] && RUN_ENVS+=( -e "AUTO_UPDATE_ON_START=$AUTO_UPDATE_ON_START" )
[ -n "$UPDATE_CHECK_INTERVAL_SECONDS" ] && RUN_ENVS+=( -e "UPDATE_CHECK_INTERVAL_SECONDS=$UPDATE_CHECK_INTERVAL_SECONDS" )
[ -n "$APPROVAL_FILE" ] && RUN_ENVS+=( -e "APPROVAL_FILE=$APPROVAL_FILE" )


if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "docker run envs: ${RUN_ENVS[*]}"
  docker run -d --name "$CONTAINER_NAME" "${RUN_ENVS[@]}" -p "$HOST_PORT":8080 "$FULL_TAG" | tee "$DOCKER_RUN_LOG"
  echo "[INFO] Docker run log saved to $DOCKER_RUN_LOG"
else
  docker run -d --name "$CONTAINER_NAME" "${RUN_ENVS[@]}" -p "$HOST_PORT":8080 "$FULL_TAG" > "$DOCKER_RUN_LOG" 2>&1
fi

# Wait a moment for the container to start
sleep 2

# Check for test mode early - monitor for tunnel connection and auto-terminate
if [ "$TEST_MODE" = "true" ]; then
  # Test mode: stream all server logs transparently for testing
  echo "[INFO] Test mode: streaming all VS Code Server output."
  echo "Container '$CONTAINER_NAME' is running on port $HOST_PORT."
  echo "--- VS Code Server Output ---"
  echo "All server logs will be displayed below for testing purposes."
  echo "=========================================="

  # Simply stream all logs transparently
  docker logs -f "$CONTAINER_NAME" 2>&1 &
  LOGS_PID=$!
  sleep 120

  if kill -0 "$LOGS_PID" 2>/dev/null; then
    kill "$LOGS_PID" 2>/dev/null || true
    wait "$LOGS_PID" 2>/dev/null || true
  fi

  echo ""
  echo "=========================================="
  echo "[INFO] Test mode completed. All VS Code Server output shown above."
  echo "[INFO] Container remains running for manual testing."
  echo "[INFO] Check logs anytime with: docker logs $CONTAINER_NAME"
  exit 0
fi

# Configure Copilot autonomous mode if requested
if [ "$COPILOT_AUTONOMOUS" = "true" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Configuring VS Code for autonomous Copilot terminal commands..."
  fi
  
  # Create the VS Code server settings directory
  docker exec "$CONTAINER_NAME" mkdir -p "/home/devuser/.vscode-server/data/Machine" >/dev/null 2>&1
  
  # Create the settings.json content for autonomous Copilot
  COPILOT_SETTINGS='{
    "chat.tools.terminal.autoApprove": {
        "/.*/": true
    }
}'
  
  # Write the settings to the container
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Creating autonomous Copilot settings at /home/devuser/.vscode-server/data/Machine/settings.json"
    echo "$COPILOT_SETTINGS" | docker exec -i "$CONTAINER_NAME" tee "/home/devuser/.vscode-server/data/Machine/settings.json"
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "/home/devuser/.vscode-server/data/Machine/settings.json"
  else
    echo "$COPILOT_SETTINGS" | docker exec -i "$CONTAINER_NAME" tee "/home/devuser/.vscode-server/data/Machine/settings.json" >/dev/null 2>&1
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "/home/devuser/.vscode-server/data/Machine/settings.json" >/dev/null 2>&1
  fi
fi

# If the local settings.json exists, copy it into the container
if [ -f "$MAC_SETTINGS_JSON" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Copying local VS Code settings.json to container..."
    docker exec "$CONTAINER_NAME" mkdir -p "$CONTAINER_SETTINGS_DIR"
    docker cp "$MAC_SETTINGS_JSON" "$CONTAINER_NAME":"$CONTAINER_SETTINGS_JSON"
    # Ensure devuser owns the file
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "$CONTAINER_SETTINGS_JSON"
  else
    docker exec "$CONTAINER_NAME" mkdir -p "$CONTAINER_SETTINGS_DIR" >/dev/null 2>&1
    docker cp "$MAC_SETTINGS_JSON" "$CONTAINER_NAME":"$CONTAINER_SETTINGS_JSON" >/dev/null 2>&1
    # Ensure devuser owns the file
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "$CONTAINER_SETTINGS_JSON" >/dev/null 2>&1
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "No local VS Code settings.json found at $MAC_SETTINGS_JSON. Skipping copy."
  fi
fi

if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo -e "\n--- VS Code Tunnel Setup ---"
  echo "The VS Code Server is starting up. All output will be shown below."
  echo "Look for the authentication code and tunnel link in the server output."
  echo "-------------------------------------------------"
fi

echo "Waiting for VS Code tunnel to start... (this may take up to 3 minutes)"
echo "All server output will be displayed below:"
echo ""

# Simply stream all VS Code server logs to the terminal
# This ensures all information is visible regardless of format changes
TIMEOUT=180  # 3 minutes timeout
echo "Starting VS Code Server output stream..."
echo "=========================================="

# Stream logs in real-time
docker logs -f "$CONTAINER_NAME" 2>&1 &
LOG_PID=$!

# Set up cleanup for the background process
trap 'if [ -n "$LOG_PID" ] && kill -0 "$LOG_PID" 2>/dev/null; then kill "$LOG_PID" 2>/dev/null; fi' EXIT

# Wait for the process to complete or timeout
TIMEOUT_REACHED=false
for i in $(seq 1 $TIMEOUT); do
  if ! kill -0 $LOG_PID 2>/dev/null; then
    # Process completed
    wait $LOG_PID 2>/dev/null
    break
  fi

  # Show progress every 30 seconds
  if [ $((i % 30)) -eq 0 ]; then
    echo ""
    echo "[INFO] Still waiting for tunnel setup... ($i/$TIMEOUT seconds)"
    echo "=========================================="
  fi

  sleep 1
done

# Check if we timed out
if kill -0 $LOG_PID 2>/dev/null; then
  TIMEOUT_REACHED=true
  echo ""
  echo "[INFO] Timeout reached after $TIMEOUT seconds."
  echo "[INFO] The VS Code Server may still be starting up."
  kill $LOG_PID 2>/dev/null
  wait $LOG_PID 2>/dev/null
fi

echo ""
echo "=========================================="
if [ "$TIMEOUT_REACHED" = "true" ]; then
  echo " Tunnel setup is taking longer than expected."
  echo " The server may still be initializing."
  echo " Check the full logs: docker logs $CONTAINER_NAME"
  echo " Or visit: https://vscode.dev/tunnels"
else
  echo " VS Code Server startup process completed."
  echo " If you don't see the tunnel link above, check: docker logs $CONTAINER_NAME"
  echo " Or visit: https://vscode.dev/tunnels"
fi

# Clear the EXIT trap since we're handling cleanup manually now
trap - EXIT

if [ "$TIMEOUT_REACHED" = "false" ]; then
  echo -e "\nTunnel established. You can now connect using the above link."
else
  echo -e "\nContainer is running but tunnel link detection timed out."
fi

if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "Container $CONTAINER_NAME is running on port $HOST_PORT. To stop it: docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME"
else
  echo "Container $CONTAINER_NAME is running on port $HOST_PORT."
fi
