#!/bin/bash

# Generated by Copilot (GPT-4o), 2025-08-30
# Description: Unit test runner for shell script components
# Tests individual functions and components of the build system

set -euo pipefail

# Source common testing utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOGS_DIR="$SCRIPT_DIR/../logs"
TEST_LOG="$LOGS_DIR/unit-test-$(date +%s).log"

mkdir -p "$LOGS_DIR"

# Test utilities
assert_equals() {
    local expected="$1"
    local actual="$2"
    local message="${3:-}"
    
    if [[ "$expected" != "$actual" ]]; then
        echo "FAIL: $message" | tee -a "$TEST_LOG"
        echo "  Expected: '$expected'" | tee -a "$TEST_LOG"
        echo "  Actual: '$actual'" | tee -a "$TEST_LOG"
        return 1
    else
        echo "PASS: $message" | tee -a "$TEST_LOG"
        return 0
    fi
}

test_yaml_parsing() {
    echo "Testing YAML parsing functions..." | tee -a "$TEST_LOG"
    
    # Create test YAML file
    local test_yaml="/tmp/test_unit.yaml"
    cat > "$test_yaml" << 'EOF'
tunnel_name: test_tunnel
force_analysis: true
logging: false
EOF

    # Test parsing function (mock implementation)
    parse_yaml() {
        local file="$1"
        local key="$2"
        grep "^$key:" "$file" | cut -d: -f2 | xargs
    }
    
    local tunnel_name
    tunnel_name=$(parse_yaml "$test_yaml" "tunnel_name")
    assert_equals "test_tunnel" "$tunnel_name" "YAML tunnel_name parsing"
    
    local force_analysis
    force_analysis=$(parse_yaml "$test_yaml" "force_analysis")
    assert_equals "true" "$force_analysis" "YAML force_analysis parsing"
    
    rm -f "$test_yaml"
}

test_docker_functions() {
    echo "Testing Docker utility functions..." | tee -a "$TEST_LOG"
    
    # Test container name generation
    generate_container_name() {
        local base_name="$1"
        local timestamp="$2"
        echo "${base_name}-${timestamp}"
    }
    
    local container_name
    container_name=$(generate_container_name "test" "123456")
    assert_equals "test-123456" "$container_name" "Container name generation"
    
    # Test image tag validation
    validate_image_tag() {
        local tag="$1"
        if [[ "$tag" =~ ^[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]]; then
            echo "valid"
        else
            echo "invalid"
        fi
    }
    
    local tag_result
    tag_result=$(validate_image_tag "vscode-debian-slim")
    assert_equals "valid" "$tag_result" "Valid image tag recognition"
    
    tag_result=$(validate_image_tag "invalid tag with spaces")
    assert_equals "invalid" "$tag_result" "Invalid image tag recognition"
}

test_logging_functions() {
    echo "Testing logging functions..." | tee -a "$TEST_LOG"
    
    # Test log level filtering
    filter_log_level() {
        local level="$1"
        local message="$2"
        echo "[$level] $message"
    }
    
    local log_message
    log_message=$(filter_log_level "INFO" "Test message")
    assert_equals "[INFO] Test message" "$log_message" "Log level formatting"
    
    # Test timestamp formatting
    format_timestamp() {
        date -d "@$1" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date -r "$1" "+%Y-%m-%d %H:%M:%S"
    }
    
    # Test with known timestamp (January 1, 2025, 00:00:00 UTC)
    local formatted_time
    formatted_time=$(format_timestamp "1735689600")
    # Note: This will vary by timezone, so we just check the format
    if [[ "$formatted_time" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
        echo "PASS: Timestamp formatting" | tee -a "$TEST_LOG"
    else
        echo "FAIL: Timestamp formatting - got '$formatted_time'" | tee -a "$TEST_LOG"
        return 1
    fi
}

test_error_handling() {
    echo "Testing error handling functions..." | tee -a "$TEST_LOG"
    
    # Test exit code handling
    handle_exit_code() {
        local exit_code="$1"
        local operation="$2"
        
        if [[ "$exit_code" -eq 0 ]]; then
            echo "SUCCESS: $operation"
        else
            echo "ERROR: $operation failed with exit code $exit_code"
        fi
    }
    
    local result
    result=$(handle_exit_code 0 "test operation")
    assert_equals "SUCCESS: test operation" "$result" "Success exit code handling"
    
    result=$(handle_exit_code 1 "test operation")
    assert_equals "ERROR: test operation failed with exit code 1" "$result" "Error exit code handling"
}

# Run all unit tests
main() {
    echo "Starting unit tests..." | tee -a "$TEST_LOG"
    local test_failures=0
    
    test_yaml_parsing || ((test_failures++))
    test_docker_functions || ((test_failures++))
    test_logging_functions || ((test_failures++))
    test_error_handling || ((test_failures++))
    
    echo "Unit tests completed." | tee -a "$TEST_LOG"
    echo "Test failures: $test_failures" | tee -a "$TEST_LOG"
    
    if [[ "$test_failures" -eq 0 ]]; then
        echo "All unit tests passed!" | tee -a "$TEST_LOG"
        exit 0
    else
        echo "Some unit tests failed!" | tee -a "$TEST_LOG"
        exit 1
    fi
}

main "$@"
