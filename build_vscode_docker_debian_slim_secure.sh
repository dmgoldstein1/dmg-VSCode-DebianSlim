# Generated by Copilot (GPT-4)
# This script builds the VS Code Debian Slim Docker image with a deterministic tag based on the base image and dependencies.
# After building, it runs Docker Scout CVE and recommendations analysis, saves logs, and prints a summary of vulnerability counts (critical, high, medium, low, unspecified) for the entire image (npm and system packages).
# Usage: ./build_vscode_docker_debian_slim_secure.sh

set -e

DOCKERFILE=Dockerfile
IMAGE_NAME=dmg-vs-code-debian-slim

# Extract the base image version (debian:stable-slim)
BASE_IMAGE=$(grep '^FROM' "$DOCKERFILE" | awk '{print $2}')

# Get the digest of the base image
BASE_DIGEST=$(docker pull "$BASE_IMAGE" | grep 'Digest:' | awk '{print $2}')

# Get all dependency lines (RUN, ADD, COPY)
DEPENDENCY_LINES=$(grep -E '^(RUN|ADD|COPY)' "$DOCKERFILE")

# Compute hash from base image + digest + dependency lines (cross-platform)
HASH_INPUT="$BASE_IMAGE@$BASE_DIGEST\n$DEPENDENCY_LINES"
if command -v sha256sum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | sha256sum | awk '{print $1}' | cut -c1-12)
elif command -v shasum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | shasum -a 256 | awk '{print $1}' | cut -c1-12)
else
  echo "Error: Neither sha256sum nor shasum found. Please install one of them." >&2
  exit 1
fi


# --- Security Remediation Steps ---
# 1. Run npm audit fix in a temp container (if npm is present)
echo "Running npm audit fix in a temp container (if npm is present)..."
docker run --rm -it "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' || true

# 2. Run apt-get update/upgrade in a temp container (if apt is present)
echo "Running apt-get update/upgrade in a temp container (if apt is present)..."
docker run --rm -it "$FULL_TAG" sh -c 'if command -v apt-get >/dev/null 2>&1; then apt-get update && apt-get upgrade -y || true; fi' || true

# --- Rebuild image after remediation steps (optional: user may want to commit these changes in a Dockerfile for persistence) ---
# (Not rebuilding here, just analyzing the original build)

# --- Docker Scout Analysis ---
SCOUT_CVES_LOG="docker-scout-cves-$(date +%s).log"
docker scout cves "$FULL_TAG" | tee "$SCOUT_CVES_LOG"

SCOUT_RECOMMENDATIONS_LOG="docker-scout-recommendations-$(date +%s).log"
docker scout recommendations "$FULL_TAG" | tee "$SCOUT_RECOMMENDATIONS_LOG"

# --- Enhanced Vulnerability Summary ---
# For each tier, count total and how many have/don't have a public patch
echo "\nVulnerability summary for $FULL_TAG:" | tee -a "$SCOUT_CVES_LOG"

# Use gawk if available, otherwise use BSD awk-compatible logic
if command -v gawk >/dev/null 2>&1; then
  gawk '
  BEGIN {
    split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
    for (i in sevlist) {
      t = sevlist[i];
      total[t]=0; fixed[t]=0; unfixed[t]=0;
    }
    inblock=0;
    blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    blockpatch="";
  }
  {
    print "DEBUG: Processing line: " $0 > "/dev/stderr";
    if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
      # Start of a new block
      inblock=1;
      blockpatch="not fixed";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      while (match($0, /([0-9]+)([CHMLU\?])/, arr)) {
        sev = (arr[2]=="C") ? "CRITICAL" : (arr[2]=="H") ? "HIGH" : (arr[2]=="M") ? "MEDIUM" : (arr[2]=="L") ? "LOW" : "UNSPECIFIED";
        blockcounts[sev] = arr[1];
        $0 = substr($0, RSTART + RLENGTH);
      }
      for (s in blockcounts) {
        if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
      }
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
      blockpatch="not fixed";
      print "DEBUG: Patch status: not fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
      blockpatch="fixed";
      print "DEBUG: Patch status: fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /^$/) {
      # End of block
      for (s in blockcounts) {
        if (blockcounts[s]>0) {
          if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
          else unfixed[s]+=blockcounts[s];
          total[s]+=blockcounts[s];
          print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
        }
      }
      inblock=0;
      blockpatch="";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    }
  }
  END {
    for (i in sevlist) {
      t = sevlist[i];
      printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      if (total[t] != fixed[t] + unfixed[t]) {
        printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
      }
    }
  }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
else
  awk '
  BEGIN {
    split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
    for (i in sevlist) {
      t = sevlist[i];
      total[t]=0; fixed[t]=0; unfixed[t]=0;
    }
    inblock=0;
    blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    blockpatch="";
  }
  {
    print "DEBUG: Processing line: " $0 > "/dev/stderr";
    if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
      # Start of a new block
      inblock=1;
      blockpatch="not fixed";
      c = h = m = l = u = 0;
      line = $0;
      n = split(line, fields, /[[:space:]]+/);
      for (i = 1; i <= n; i++) {
        if (fields[i] ~ /C$/) { c = substr(fields[i], 1, length(fields[i])-1); blockcounts["CRITICAL"]=c; }
        if (fields[i] ~ /H$/) { h = substr(fields[i], 1, length(fields[i])-1); blockcounts["HIGH"]=h; }
        if (fields[i] ~ /M$/) { m = substr(fields[i], 1, length(fields[i])-1); blockcounts["MEDIUM"]=m; }
        if (fields[i] ~ /L$/) { l = substr(fields[i], 1, length(fields[i])-1); blockcounts["LOW"]=l; }
        if (fields[i] ~ /\?$/) { u = substr(fields[i], 1, length(fields[i])-1); blockcounts["UNSPECIFIED"]=u; }
      }
      for (s in blockcounts) {
        if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
      }
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
      blockpatch="not fixed";
      print "DEBUG: Patch status: not fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
      blockpatch="fixed";
      print "DEBUG: Patch status: fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /^$/) {
      # End of block
      for (s in blockcounts) {
        if (blockcounts[s]>0) {
          if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
          else unfixed[s]+=blockcounts[s];
          total[s]+=blockcounts[s];
          print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
        }
      }
      inblock=0;
      blockpatch="";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    }
  }
  END {
    for (i in sevlist) {
      t = sevlist[i];
      printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      if (total[t] != fixed[t] + unfixed[t]) {
        printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
      }
    }
  }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
fi
echo "\nSee $SCOUT_CVES_LOG and $SCOUT_RECOMMENDATIONS_LOG for full details." | tee -a "$SCOUT_CVES_LOG"
