# Generated by Copilot (GPT-4)
# This script now supports passing an optional tunnel name as the first argument.
# This script builds the VS Code Debian Slim Docker image with a deterministic tag based on the base image and dependencies.
# After building, it runs Docker Scout CVE and recommendations analysis, saves logs, and prints a summary of vulnerability counts (critical, high, medium, low, unspecified) for the entire image (npm and system packages).
# Usage: ./build_vscode_docker_debian_slim_secure.sh


set -e

# Usage: ./build_vscode_docker_debian_slim_secure.sh [TunnelName] [--force-analysis] [--logging] [--copilot-is-autonomous] [--git-user-name NAME] [--git-user-email EMAIL] [--use-yaml]
#   --logging: Enables verbose logging output for debugging and detailed progress.
#   --copilot-is-autonomous: Configures VS Code to auto-approve terminal commands for GitHub Copilot.
#   --git-user-name: Git user.name to pass into the container (exported as GIT_USER_NAME).
#   --git-user-email: Git user.email to pass into the container (exported as GIT_USER_EMAIL).
#   --use-yaml: Ignore other flags/args and load configuration from build_variables.yaml in this directory.

# Parse arguments and (optionally) a YAML config file
# If --use-yaml is present, ignore all other flags/args and source values from build_variables.yaml

# Defaults
TUNNEL_NAME_ARG=""
FORCE_ANALYSIS=false
VERBOSE_LOGGING=false
COPILOT_AUTONOMOUS=false
GIT_USER_NAME=""
GIT_USER_EMAIL=""
GH_TOKEN=""
AUTO_UPDATE_ON_START=""
UPDATE_CHECK_INTERVAL_SECONDS=""
APPROVAL_FILE=""
USE_YAML=false
YAML_FILE="build_variables.yaml"

# Pre-scan to detect --use-yaml
for pre in "$@"; do
  [ "$pre" = "--use-yaml" ] && USE_YAML=true && break
done

parse_bool() {
  case "$1" in
    true|TRUE|True|1|yes|YES|y|Y) echo "true" ;;
    false|FALSE|False|0|no|NO|n|N|"") echo "false" ;;
    *) echo "$1" ;;
  esac
}

load_yaml_config() {
  local file="$1"
  if [ ! -f "$file" ]; then
    echo "Error: --use-yaml specified but $file not found." >&2
    exit 3
  fi
  # Simple YAML (key: value) parser; ignores comments and nested structures
  # Supported keys:
  #   tunnel_name, force_analysis, logging, copilot_is_autonomous,
  #   git_user_name, git_user_email, gh_token,
  #   auto_update_on_start, update_check_interval_seconds, approval_file
  while IFS= read -r line; do
    # strip comments
    line="${line%%#*}"
    # trim
    line="$(echo "$line" | sed -e 's/^\s*//' -e 's/\s*$//')"
    [ -z "$line" ] && continue
    key="${line%%:*}"
    val="${line#*:}"
    key="$(echo "$key" | sed -e 's/^\s*//' -e 's/\s*$//')"
    val="$(echo "$val" | sed -e 's/^\s*//' -e 's/\s*$//')"
    # remove optional surrounding quotes
    val="$(echo "$val" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")"
    case "$key" in
      tunnel_name) TUNNEL_NAME_ARG="$val" ;;
      force_analysis) FORCE_ANALYSIS=$(parse_bool "$val") ;;
      logging) VERBOSE_LOGGING=$(parse_bool "$val") ;;
      copilot_is_autonomous) COPILOT_AUTONOMOUS=$(parse_bool "$val") ;;
      git_user_name) GIT_USER_NAME="$val" ;;
      git_user_email) GIT_USER_EMAIL="$val" ;;
      gh_token) GH_TOKEN="$val" ;;
      auto_update_on_start) AUTO_UPDATE_ON_START="$val" ;;
      update_check_interval_seconds) UPDATE_CHECK_INTERVAL_SECONDS="$val" ;;
      approval_file) APPROVAL_FILE="$val" ;;
      *)
        # unknown key ignored (forward compatibility)
        ;;
    esac
  done < "$file"
}

if [ "$USE_YAML" = "true" ]; then
  load_yaml_config "$YAML_FILE"
else
  # Flag parser (no YAML). Supports positional TunnelName and explicit flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --force-analysis)
        FORCE_ANALYSIS=true
        shift ;;
      --logging)
        VERBOSE_LOGGING=true
        shift ;;
      --copilot-is-autonomous)
        COPILOT_AUTONOMOUS=true
        shift ;;
      --git-user-name)
        GIT_USER_NAME="$2"; shift 2 ;;
      --git-user-email)
        GIT_USER_EMAIL="$2"; shift 2 ;;
      --gh-token)
        GH_TOKEN="$2"; shift 2 ;;
      --auto-update-on-start)
        AUTO_UPDATE_ON_START="$2"; shift 2 ;;
      --update-check-interval-seconds)
        UPDATE_CHECK_INTERVAL_SECONDS="$2"; shift 2 ;;
      --approval-file)
        APPROVAL_FILE="$2"; shift 2 ;;
      --use-yaml)
        # Handled earlier; ensure we ignore the rest by loading and breaking
        USE_YAML=true
        shift
        load_yaml_config "$YAML_FILE"
        break ;;
      --)
        shift; break ;;
      -*)
        echo "Warning: Unknown flag '$1' ignored" >&2
        shift ;;
      *)
        # first non-flag token = tunnel name (if not set yet)
        if [ -z "$TUNNEL_NAME_ARG" ]; then
          TUNNEL_NAME_ARG="$1"
        fi
        shift ;;
    esac
  done
fi

if [ -n "$TUNNEL_NAME_ARG" ]; then
  echo "Tunnel name argument provided: $TUNNEL_NAME_ARG"
  # Validate: only numbers, lowercase letters, and underscores allowed
  if ! echo "$TUNNEL_NAME_ARG" | grep -Eq '^[a-z0-9_]+$'; then
    echo "Error: Tunnel name '$TUNNEL_NAME_ARG' is invalid. Only numbers, lowercase letters, and underscores are allowed. No capital letters or special characters permitted."
    exit 2
  fi
fi

if [ "$USE_YAML" = "true" ] && [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "Loaded configuration from $YAML_FILE."
  echo "- force_analysis=$FORCE_ANALYSIS"
  echo "- logging=$VERBOSE_LOGGING"
  echo "- copilot_is_autonomous=$COPILOT_AUTONOMOUS"
  echo "- tunnel_name=$TUNNEL_NAME_ARG"
  echo "- git_user_name set? $( [ -n \"$GIT_USER_NAME\" ] && echo yes || echo no )"
  echo "- git_user_email set? $( [ -n \"$GIT_USER_EMAIL\" ] && echo yes || echo no )"
  echo "- gh_token set? $( [ -n \"$GH_TOKEN\" ] && echo yes || echo no )"
  echo "- auto_update_on_start=$AUTO_UPDATE_ON_START"
  echo "- update_check_interval_seconds=$UPDATE_CHECK_INTERVAL_SECONDS"
  echo "- approval_file=$APPROVAL_FILE"
fi


DOCKERFILE=Dockerfile
IMAGE_NAME=dmg-vs-code-debian-slim

# Extract the base image version (debian:stable-slim)
BASE_IMAGE=$(grep '^FROM' "$DOCKERFILE" | awk '{print $2}')

# Get the digest of the base image
BASE_DIGEST=$(docker pull "$BASE_IMAGE" | grep 'Digest:' | awk '{print $2}')

# Get all dependency lines (RUN, ADD, COPY)
DEPENDENCY_LINES=$(grep -E '^(RUN|ADD|COPY)' "$DOCKERFILE")

# Compute hash from base image + digest + dependency lines (cross-platform)
HASH_INPUT="$BASE_IMAGE@$BASE_DIGEST\n$DEPENDENCY_LINES"
if command -v sha256sum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | sha256sum | awk '{print $1}' | cut -c1-12)
elif command -v shasum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | shasum -a 256 | awk '{print $1}' | cut -c1-12)
else
  echo "Error: Neither sha256sum nor shasum found. Please install one of them." >&2
  exit 1
fi

FULL_TAG="$IMAGE_NAME:$TAG"

# --- Build the container if it does not exist ---
IMAGE_ALREADY_EXISTS=false
if ! docker image inspect "$FULL_TAG" >/dev/null 2>&1; then
  echo "Container image $FULL_TAG not found. Building..."
  docker build -t "$FULL_TAG" -f "$DOCKERFILE" .
else
  echo "Container image $FULL_TAG already exists."
  IMAGE_ALREADY_EXISTS=true
fi

# --- Security Remediation Steps (skip if image already exists) ---
if [ "$IMAGE_ALREADY_EXISTS" = "false" ]; then
  # 1. Run npm audit fix in a temp container (if npm is present)
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Running npm audit fix in a temp container (if npm is present)..."
    docker run --rm -it "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' || true
  else
    docker run --rm "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' >/dev/null 2>&1 || true
  fi
  
  # 2. Run apt-get update/upgrade in a temp container (if apt is present)
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Running apt-get update/upgrade in a temp container (if apt is present)..."
    docker run --rm "$FULL_TAG" sh -c '\
      if command -v apt-get >/dev/null 2>&1; then \
        apt-get update && \
        apt-get upgrade -y || true; \
      fi' || true
  else
    docker run --rm "$FULL_TAG" sh -c '\
      if command -v apt-get >/dev/null 2>&1; then \
        apt-get update >/dev/null 2>&1 && \
        apt-get upgrade -y >/dev/null 2>&1 || true; \
      fi' >/dev/null 2>&1 || true
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Skipping security remediation steps (image already exists and analyzed)."
  fi
fi
# --- Rebuild image after remediation steps (optional: user may want to commit these changes in a Dockerfile for persistence) ---
# (Not rebuilding here, just analyzing the original build)

# --- Docker Scout Analysis (skip if image already exists and logs exist) ---
SCOUT_CVES_LOG="docker-scout-cves-$TAG.log"
SCOUT_RECOMMENDATIONS_LOG="docker-scout-recommendations-$TAG.log"

if [ "$IMAGE_ALREADY_EXISTS" = "true" ] && [ -f "$SCOUT_CVES_LOG" ] && [ -f "$SCOUT_RECOMMENDATIONS_LOG" ] && [ "$FORCE_ANALYSIS" = "false" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Using existing Docker Scout analysis for $FULL_TAG (use --force-analysis to re-run)..."
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Running Docker Scout analysis for $FULL_TAG..."
    docker scout cves "$FULL_TAG" | tee "$SCOUT_CVES_LOG"
    docker scout recommendations "$FULL_TAG" | tee "$SCOUT_RECOMMENDATIONS_LOG"
  else
    echo "Running vulnerability analysis..."
    docker scout cves "$FULL_TAG" > "$SCOUT_CVES_LOG" 2>&1
    docker scout recommendations "$FULL_TAG" > "$SCOUT_RECOMMENDATIONS_LOG" 2>&1
  fi
fi

# --- Enhanced Vulnerability Summary ---
# For each tier, count total and how many have/don't have a public patch
if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo -e "\nVulnerability summary for $FULL_TAG:" | tee -a "$SCOUT_CVES_LOG"
else
  echo "Analyzing vulnerabilities..."
fi

# Use gawk if available, otherwise use BSD awk-compatible logic
if command -v gawk >/dev/null 2>&1; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    gawk '
    BEGIN {
      split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
      for (i in sevlist) {
        t = sevlist[i];
        total[t]=0; fixed[t]=0; unfixed[t]=0;
      }
      inblock=0;
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      blockpatch="";
    }
    {
      print "DEBUG: Processing line: " $0 > "/dev/stderr";
      if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
        # Start of a new block
        inblock=1;
        blockpatch="not fixed";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
        while (match($0, /([0-9]+)([CHMLU\?])/, arr)) {
          sev = (arr[2]=="C") ? "CRITICAL" : (arr[2]=="H") ? "HIGH" : (arr[2]=="M") ? "MEDIUM" : (arr[2]=="L") ? "LOW" : "UNSPECIFIED";
          blockcounts[sev] = arr[1];
          $0 = substr($0, RSTART + RLENGTH);
        }
        for (s in blockcounts) {
          if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
        }
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
        blockpatch="not fixed";
        print "DEBUG: Patch status: not fixed" > "/dev/stderr";
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
        blockpatch="fixed";
        print "DEBUG: Patch status: fixed" > "/dev/stderr";
      } else if (inblock && $0 ~ /^$/) {
        # End of block
        for (s in blockcounts) {
          if (blockcounts[s]>0) {
            if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
            else unfixed[s]+=blockcounts[s];
            total[s]+=blockcounts[s];
            print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
          }
        }
        inblock=0;
        blockpatch="";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      }
    }
    END {
      for (i in sevlist) {
        t = sevlist[i];
        printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
        if (total[t] != fixed[t] + unfixed[t]) {
          printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
        }
      }
    }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
  else
    gawk '
    BEGIN {
      split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
      for (i in sevlist) {
        t = sevlist[i];
        total[t]=0; fixed[t]=0; unfixed[t]=0;
      }
      inblock=0;
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      blockpatch="";
    }
    {
      if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
        # Start of a new block
        inblock=1;
        blockpatch="not fixed";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
        while (match($0, /([0-9]+)([CHMLU\?])/, arr)) {
          sev = (arr[2]=="C") ? "CRITICAL" : (arr[2]=="H") ? "HIGH" : (arr[2]=="M") ? "MEDIUM" : (arr[2]=="L") ? "LOW" : "UNSPECIFIED";
          blockcounts[sev] = arr[1];
          $0 = substr($0, RSTART + RLENGTH);
        }
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
        blockpatch="not fixed";
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
        blockpatch="fixed";
      } else if (inblock && $0 ~ /^$/) {
        # End of block
        for (s in blockcounts) {
          if (blockcounts[s]>0) {
            if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
            else unfixed[s]+=blockcounts[s];
            total[s]+=blockcounts[s];
          }
        }
        inblock=0;
        blockpatch="";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      }
    }
    END {
      for (i in sevlist) {
        t = sevlist[i];
        printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      }
    }' "$SCOUT_CVES_LOG"
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    awk '
    BEGIN {
      split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
      for (i in sevlist) {
        t = sevlist[i];
        total[t]=0; fixed[t]=0; unfixed[t]=0;
      }
      inblock=0;
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      blockpatch="";
    }
    {
      print "DEBUG: Processing line: " $0 > "/dev/stderr";
      if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
        # Start of a new block
        inblock=1;
        blockpatch="not fixed";
        c = h = m = l = u = 0;
        line = $0;
        n = split(line, fields, /[[:space:]]+/);
        for (i = 1; i <= n; i++) {
          if (fields[i] ~ /C$/) { c = substr(fields[i], 1, length(fields[i])-1); blockcounts["CRITICAL"]=c; }
          if (fields[i] ~ /H$/) { h = substr(fields[i], 1, length(fields[i])-1); blockcounts["HIGH"]=h; }
          if (fields[i] ~ /M$/) { m = substr(fields[i], 1, length(fields[i])-1); blockcounts["MEDIUM"]=m; }
          if (fields[i] ~ /L$/) { l = substr(fields[i], 1, length(fields[i])-1); blockcounts["LOW"]=l; }
          if (fields[i] ~ /\?$/) { u = substr(fields[i], 1, length(fields[i])-1); blockcounts["UNSPECIFIED"]=u; }
        }
        for (s in blockcounts) {
          if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
        }
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
        blockpatch="not fixed";
        print "DEBUG: Patch status: not fixed" > "/dev/stderr";
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
        blockpatch="fixed";
        print "DEBUG: Patch status: fixed" > "/dev/stderr";
      } else if (inblock && $0 ~ /^$/) {
        # End of block
        for (s in blockcounts) {
          if (blockcounts[s]>0) {
            if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
            else unfixed[s]+=blockcounts[s];
            total[s]+=blockcounts[s];
            print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
          }
        }
        inblock=0;
        blockpatch="";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      }
    }
    END {
      for (i in sevlist) {
        t = sevlist[i];
        printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
        if (total[t] != fixed[t] + unfixed[t]) {
          printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
        }
      }
    }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
  else
    awk '
    BEGIN {
      split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
      for (i in sevlist) {
        t = sevlist[i];
        total[t]=0; fixed[t]=0; unfixed[t]=0;
      }
      inblock=0;
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      blockpatch="";
    }
    {
      if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
        # Start of a new block
        inblock=1;
        blockpatch="not fixed";
        c = h = m = l = u = 0;
        line = $0;
        n = split(line, fields, /[[:space:]]+/);
        for (i = 1; i <= n; i++) {
          if (fields[i] ~ /C$/) { c = substr(fields[i], 1, length(fields[i])-1); blockcounts["CRITICAL"]=c; }
          if (fields[i] ~ /H$/) { h = substr(fields[i], 1, length(fields[i])-1); blockcounts["HIGH"]=h; }
          if (fields[i] ~ /M$/) { m = substr(fields[i], 1, length(fields[i])-1); blockcounts["MEDIUM"]=m; }
          if (fields[i] ~ /L$/) { l = substr(fields[i], 1, length(fields[i])-1); blockcounts["LOW"]=l; }
          if (fields[i] ~ /\?$/) { u = substr(fields[i], 1, length(fields[i])-1); blockcounts["UNSPECIFIED"]=u; }
        }
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
        blockpatch="not fixed";
      } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
        blockpatch="fixed";
      } else if (inblock && $0 ~ /^$/) {
        # End of block
        for (s in blockcounts) {
          if (blockcounts[s]>0) {
            if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
            else unfixed[s]+=blockcounts[s];
            total[s]+=blockcounts[s];
          }
        }
        inblock=0;
        blockpatch="";
        blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      }
    }
    END {
      for (i in sevlist) {
        t = sevlist[i];
        printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      }
    }' "$SCOUT_CVES_LOG"
  fi
fi

# --- Copilot (GPT-4) generated: Launch container and display VS Code Tunnel token ---
# This section ensures the container is running and the user sees the tunnel auth code and link in the terminal output.


# Use a unique container name if tunnel name is provided, else default
if [ -n "$TUNNEL_NAME_ARG" ]; then
  CONTAINER_NAME="$TUNNEL_NAME_ARG"
else
  CONTAINER_NAME="vscode-server-tunnel"
fi

# Stop and remove any previous container with the same name
if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
  echo "Stopping and removing previous container $CONTAINER_NAME..."
  docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
  docker rm "$CONTAINER_NAME" >/dev/null 2>&1 || true
fi


# --- Copilot (GPT-4): Copy local VS Code settings.json into the container before tunnel starts ---
MAC_SETTINGS_JSON="$HOME/Library/Application Support/Code/User/settings.json"
CONTAINER_SETTINGS_DIR="/home/devuser/.config/Code/User"
CONTAINER_SETTINGS_JSON="$CONTAINER_SETTINGS_DIR/settings.json"



# Find a free host port starting at 8080
HOST_PORT=8080
while lsof -iTCP:$HOST_PORT -sTCP:LISTEN >/dev/null 2>&1; do
  HOST_PORT=$((HOST_PORT+1))
done
if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "Using host port $HOST_PORT for container $CONTAINER_NAME (host:$HOST_PORT -> container:8080)"
fi

echo "Launching VS Code Server container as $CONTAINER_NAME..."

# Build environment list for docker run
RUN_ENVS=( )
[ -n "$TUNNEL_NAME_ARG" ] && RUN_ENVS+=( -e "TUNNEL_NAME=$TUNNEL_NAME_ARG" )
[ -n "$GIT_USER_NAME" ] && RUN_ENVS+=( -e "GIT_USER_NAME=$GIT_USER_NAME" )
[ -n "$GIT_USER_EMAIL" ] && RUN_ENVS+=( -e "GIT_USER_EMAIL=$GIT_USER_EMAIL" )
[ -n "$GH_TOKEN" ] && RUN_ENVS+=( -e "GH_TOKEN=$GH_TOKEN" )
[ -n "$AUTO_UPDATE_ON_START" ] && RUN_ENVS+=( -e "AUTO_UPDATE_ON_START=$AUTO_UPDATE_ON_START" )
[ -n "$UPDATE_CHECK_INTERVAL_SECONDS" ] && RUN_ENVS+=( -e "UPDATE_CHECK_INTERVAL_SECONDS=$UPDATE_CHECK_INTERVAL_SECONDS" )
[ -n "$APPROVAL_FILE" ] && RUN_ENVS+=( -e "APPROVAL_FILE=$APPROVAL_FILE" )

if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "docker run envs: ${RUN_ENVS[*]}"
  docker run -d --name "$CONTAINER_NAME" "${RUN_ENVS[@]}" -p "$HOST_PORT":8080 "$FULL_TAG"
else
  docker run -d --name "$CONTAINER_NAME" "${RUN_ENVS[@]}" -p "$HOST_PORT":8080 "$FULL_TAG" >/dev/null 2>&1
fi

# Wait a moment for the container to start
sleep 2

# Configure Copilot autonomous mode if requested
if [ "$COPILOT_AUTONOMOUS" = "true" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Configuring VS Code for autonomous Copilot terminal commands..."
  fi
  
  # Create the VS Code server settings directory
  docker exec "$CONTAINER_NAME" mkdir -p "/home/devuser/.vscode-server/data/Machine" >/dev/null 2>&1
  
  # Create the settings.json content for autonomous Copilot
  COPILOT_SETTINGS='{
    "chat.tools.terminal.autoApprove": {
        "/.*/": true
    }
}'
  
  # Write the settings to the container
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Creating autonomous Copilot settings at /home/devuser/.vscode-server/data/Machine/settings.json"
    echo "$COPILOT_SETTINGS" | docker exec -i "$CONTAINER_NAME" tee "/home/devuser/.vscode-server/data/Machine/settings.json"
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "/home/devuser/.vscode-server/data/Machine/settings.json"
  else
    echo "$COPILOT_SETTINGS" | docker exec -i "$CONTAINER_NAME" tee "/home/devuser/.vscode-server/data/Machine/settings.json" >/dev/null 2>&1
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "/home/devuser/.vscode-server/data/Machine/settings.json" >/dev/null 2>&1
  fi
fi

# If the local settings.json exists, copy it into the container
if [ -f "$MAC_SETTINGS_JSON" ]; then
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "Copying local VS Code settings.json to container..."
    docker exec "$CONTAINER_NAME" mkdir -p "$CONTAINER_SETTINGS_DIR"
    docker cp "$MAC_SETTINGS_JSON" "$CONTAINER_NAME":"$CONTAINER_SETTINGS_JSON"
    # Ensure devuser owns the file
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "$CONTAINER_SETTINGS_JSON"
  else
    docker exec "$CONTAINER_NAME" mkdir -p "$CONTAINER_SETTINGS_DIR" >/dev/null 2>&1
    docker cp "$MAC_SETTINGS_JSON" "$CONTAINER_NAME":"$CONTAINER_SETTINGS_JSON" >/dev/null 2>&1
    # Ensure devuser owns the file
    docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "$CONTAINER_SETTINGS_JSON" >/dev/null 2>&1
  fi
else
  if [ "$VERBOSE_LOGGING" = "true" ]; then
    echo "No local VS Code settings.json found at $MAC_SETTINGS_JSON. Skipping copy."
  fi
fi

# Wait for the tunnel server to start and print the auth code and tunnel link
if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo -e "\n--- VS Code Tunnel Auth Token and Link ---"
  echo "(If not already authenticated, copy the code and link below to set up your GitHub tunnel.)"
  echo "-------------------------------------------------"
fi
# Copilot (GPT-4): Print both the auth code and tunnel link, then exit after the tunnel link is seen
docker logs -f "$CONTAINER_NAME" 2>&1 | \
  awk '
    /use code [A-Z0-9-]{4,}/ { print "Auth code: "$0; seen_code=1; fflush(); }
    /Tunnel link: Open this link in your browser https:\/\/vscode\.dev\/tunnel\/[a-zA-Z0-9]+/ { print "Tunnel link: "$0; fflush(); exit 0; }
  '

echo -e "\nTunnel established. You can now connect using the above link."
if [ "$VERBOSE_LOGGING" = "true" ]; then
  echo "Container $CONTAINER_NAME is running on port $HOST_PORT. To stop it: docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME"
else
  echo "Container $CONTAINER_NAME is running on port $HOST_PORT."
fi
