# Generated by Copilot (GPT-4)
# This script now supports passing an optional tunnel name as the first argument.
# This script builds the VS Code Debian Slim Docker image with a deterministic tag based on the base image and dependencies.
# After building, it runs Docker Scout CVE and recommendations analysis, saves logs, and prints a summary of vulnerability counts (critical, high, medium, low, unspecified) for the entire image (npm and system packages).
# Usage: ./build_vscode_docker_debian_slim_secure.sh


set -e

# Usage: ./build_vscode_docker_debian_slim_secure.sh [TunnelName]

# Parse optional tunnel name argument
TUNNEL_NAME_ARG=""
if [ $# -ge 1 ]; then
  TUNNEL_NAME_ARG="$1"
  echo "Tunnel name argument provided: $TUNNEL_NAME_ARG"
fi


DOCKERFILE=Dockerfile
IMAGE_NAME=dmg-vs-code-debian-slim

# Extract the base image version (debian:stable-slim)
BASE_IMAGE=$(grep '^FROM' "$DOCKERFILE" | awk '{print $2}')

# Get the digest of the base image
BASE_DIGEST=$(docker pull "$BASE_IMAGE" | grep 'Digest:' | awk '{print $2}')

# Get all dependency lines (RUN, ADD, COPY)
DEPENDENCY_LINES=$(grep -E '^(RUN|ADD|COPY)' "$DOCKERFILE")

# Compute hash from base image + digest + dependency lines (cross-platform)
HASH_INPUT="$BASE_IMAGE@$BASE_DIGEST\n$DEPENDENCY_LINES"
if command -v sha256sum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | sha256sum | awk '{print $1}' | cut -c1-12)
elif command -v shasum >/dev/null 2>&1; then
  TAG=$(echo -n "$HASH_INPUT" | shasum -a 256 | awk '{print $1}' | cut -c1-12)
else
  echo "Error: Neither sha256sum nor shasum found. Please install one of them." >&2
  exit 1
fi

FULL_TAG="$IMAGE_NAME:$TAG"

# --- Build the container if it does not exist ---
if ! docker image inspect "$FULL_TAG" >/dev/null 2>&1; then
  echo "Container image $FULL_TAG not found. Building..."
  docker build -t "$FULL_TAG" -f "$DOCKERFILE" .
else
  echo "Container image $FULL_TAG already exists."
fi

# --- Security Remediation Steps ---
# 1. Run npm audit fix in a temp container (if npm is present)
echo "Running npm audit fix in a temp container (if npm is present)..."
docker run --rm -it "$FULL_TAG" sh -c 'if command -v npm >/dev/null 2>&1; then find / -type d -name node_modules 2>/dev/null | while read d; do cd "$d" && npm audit fix --force || true; done; fi' || true

# 2. Run apt-get update/upgrade in a temp container (if apt is present)
echo "Running apt-get update/upgrade in a temp container (if apt is present)..."
docker run --rm -it "$FULL_TAG" sh -c 'if command -v apt-get >/dev/null 2>&1; then apt-get update && apt-get upgrade -y || true; fi' || true

# --- Rebuild image after remediation steps (optional: user may want to commit these changes in a Dockerfile for persistence) ---
# (Not rebuilding here, just analyzing the original build)

# --- Docker Scout Analysis ---
SCOUT_CVES_LOG="docker-scout-cves-$(date +%s).log"
docker scout cves "$FULL_TAG" | tee "$SCOUT_CVES_LOG"

SCOUT_RECOMMENDATIONS_LOG="docker-scout-recommendations-$(date +%s).log"
docker scout recommendations "$FULL_TAG" | tee "$SCOUT_RECOMMENDATIONS_LOG"

# --- Enhanced Vulnerability Summary ---
# For each tier, count total and how many have/don't have a public patch
echo "\nVulnerability summary for $FULL_TAG:" | tee -a "$SCOUT_CVES_LOG"

# Use gawk if available, otherwise use BSD awk-compatible logic
if command -v gawk >/dev/null 2>&1; then
  gawk '
  BEGIN {
    split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
    for (i in sevlist) {
      t = sevlist[i];
      total[t]=0; fixed[t]=0; unfixed[t]=0;
    }
    inblock=0;
    blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    blockpatch="";
  }
  {
    print "DEBUG: Processing line: " $0 > "/dev/stderr";
    if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
      # Start of a new block
      inblock=1;
      blockpatch="not fixed";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
      while (match($0, /([0-9]+)([CHMLU\?])/, arr)) {
        sev = (arr[2]=="C") ? "CRITICAL" : (arr[2]=="H") ? "HIGH" : (arr[2]=="M") ? "MEDIUM" : (arr[2]=="L") ? "LOW" : "UNSPECIFIED";
        blockcounts[sev] = arr[1];
        $0 = substr($0, RSTART + RLENGTH);
      }
      for (s in blockcounts) {
        if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
      }
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
      blockpatch="not fixed";
      print "DEBUG: Patch status: not fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
      blockpatch="fixed";
      print "DEBUG: Patch status: fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /^$/) {
      # End of block
      for (s in blockcounts) {
        if (blockcounts[s]>0) {
          if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
          else unfixed[s]+=blockcounts[s];
          total[s]+=blockcounts[s];
          print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
        }
      }
      inblock=0;
      blockpatch="";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    }
  }
  END {
    for (i in sevlist) {
      t = sevlist[i];
      printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      if (total[t] != fixed[t] + unfixed[t]) {
        printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
      }
    }
  }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
else
  awk '
  BEGIN {
    split("CRITICAL HIGH MEDIUM LOW UNSPECIFIED", sevlist, " ");
    for (i in sevlist) {
      t = sevlist[i];
      total[t]=0; fixed[t]=0; unfixed[t]=0;
    }
    inblock=0;
    blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    blockpatch="";
  }
  {
    print "DEBUG: Processing line: " $0 > "/dev/stderr";
    if ($0 ~ /^[[:space:]]*[0-9]+[CHMLU]/) {
      # Start of a new block
      inblock=1;
      blockpatch="not fixed";
      c = h = m = l = u = 0;
      line = $0;
      n = split(line, fields, /[[:space:]]+/);
      for (i = 1; i <= n; i++) {
        if (fields[i] ~ /C$/) { c = substr(fields[i], 1, length(fields[i])-1); blockcounts["CRITICAL"]=c; }
        if (fields[i] ~ /H$/) { h = substr(fields[i], 1, length(fields[i])-1); blockcounts["HIGH"]=h; }
        if (fields[i] ~ /M$/) { m = substr(fields[i], 1, length(fields[i])-1); blockcounts["MEDIUM"]=m; }
        if (fields[i] ~ /L$/) { l = substr(fields[i], 1, length(fields[i])-1); blockcounts["LOW"]=l; }
        if (fields[i] ~ /\?$/) { u = substr(fields[i], 1, length(fields[i])-1); blockcounts["UNSPECIFIED"]=u; }
      }
      for (s in blockcounts) {
        if (blockcounts[s] > 0) print "DEBUG: Block start, severity=" s ", count=" blockcounts[s] > "/dev/stderr";
      }
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*not fixed/) {
      blockpatch="not fixed";
      print "DEBUG: Patch status: not fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /Fixed version[ ]*:[ ]*[0-9a-zA-Z.\-+]+/) {
      blockpatch="fixed";
      print "DEBUG: Patch status: fixed" > "/dev/stderr";
    } else if (inblock && $0 ~ /^$/) {
      # End of block
      for (s in blockcounts) {
        if (blockcounts[s]>0) {
          if (blockpatch=="fixed") fixed[s]+=blockcounts[s];
          else unfixed[s]+=blockcounts[s];
          total[s]+=blockcounts[s];
          print "DEBUG: Counted " blockcounts[s] " " s " (" blockpatch ")" > "/dev/stderr";
        }
      }
      inblock=0;
      blockpatch="";
      blockcounts["CRITICAL"]=0; blockcounts["HIGH"]=0; blockcounts["MEDIUM"]=0; blockcounts["LOW"]=0; blockcounts["UNSPECIFIED"]=0;
    }
  }
  END {
    for (i in sevlist) {
      t = sevlist[i];
      printf "  %s: total=%d, fixed=%d, unfixed=%d\n", t, total[t], fixed[t], unfixed[t];
      if (total[t] != fixed[t] + unfixed[t]) {
        printf "  ERROR: Arithmetic mismatch for %s: total=%d, fixed+unfixed=%d\n", t, total[t], fixed[t]+unfixed[t] > "/dev/stderr";
      }
    }
  }' "$SCOUT_CVES_LOG" | tee -a "$SCOUT_CVES_LOG"
fi

# --- Copilot (GPT-4) generated: Launch container and display VS Code Tunnel token ---
# This section ensures the container is running and the user sees the tunnel auth code and link in the terminal output.


# Use a unique container name if tunnel name is provided, else default
if [ -n "$TUNNEL_NAME_ARG" ]; then
  CONTAINER_NAME="$TUNNEL_NAME_ARG"
else
  CONTAINER_NAME="vscode-server-tunnel"
fi

# Stop and remove any previous container with the same name
if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
  echo "Stopping and removing previous container $CONTAINER_NAME..."
  docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
  docker rm "$CONTAINER_NAME" >/dev/null 2>&1 || true
fi


# --- Copilot (GPT-4): Copy local VS Code settings.json into the container before tunnel starts ---
MAC_SETTINGS_JSON="$HOME/Library/Application Support/Code/User/settings.json"
CONTAINER_SETTINGS_DIR="/home/devuser/.config/Code/User"
CONTAINER_SETTINGS_JSON="$CONTAINER_SETTINGS_DIR/settings.json"


echo "Launching VS Code Server container as $CONTAINER_NAME..."
if [ -n "$TUNNEL_NAME_ARG" ]; then
  docker run -d --name "$CONTAINER_NAME" -e TUNNEL_NAME="$TUNNEL_NAME_ARG" -p 8080:8080 "$FULL_TAG"
else
  docker run -d --name "$CONTAINER_NAME" -p 8080:8080 "$FULL_TAG"
fi

# Wait a moment for the container to start
sleep 2

# If the local settings.json exists, copy it into the container
if [ -f "$MAC_SETTINGS_JSON" ]; then
  echo "Copying local VS Code settings.json to container..."
  docker exec "$CONTAINER_NAME" mkdir -p "$CONTAINER_SETTINGS_DIR"
  docker cp "$MAC_SETTINGS_JSON" "$CONTAINER_NAME":"$CONTAINER_SETTINGS_JSON"
  # Ensure devuser owns the file
  docker exec -u root "$CONTAINER_NAME" chown devuser:devuser "$CONTAINER_SETTINGS_JSON"
else
  echo "No local VS Code settings.json found at $MAC_SETTINGS_JSON. Skipping copy."
fi

# Wait for the tunnel server to start and print the auth code and tunnel link
echo "\n--- VS Code Tunnel Auth Token and Link ---"
echo "(If not already authenticated, copy the code and link below to set up your GitHub tunnel.)"
echo "-------------------------------------------------"
# Copilot (GPT-4): Print both the auth code and tunnel link, then exit after the tunnel link is seen
docker logs -f "$CONTAINER_NAME" 2>&1 | \
  awk '
    /use code [A-Z0-9-]{4,}/ { print "Auth code: "$0; seen_code=1; fflush(); }
    /Tunnel link: Open this link in your browser https:\/\/vscode\.dev\/tunnel\/[a-zA-Z0-9]+/ { print "Tunnel link: "$0; fflush(); exit 0; }
  '

echo "\nTunnel established. You can now connect using the above link."
echo "Container $CONTAINER_NAME is running. To stop it: docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME"
