// Generated by Copilot (GPT-4) on 2025-01-26
// VS Code extension to monitor container logs for VS Code CLI updates
// Provides GUI notifications and one-click approval for updates

// ============================================================================
// EXTERNAL CONTAINER MONITORING (ALTERNATIVE IMPLEMENTATION)
// ============================================================================
//
// PURPOSE: This extension is designed to run on the HOST machine to monitor
// VS Code containers externally using Docker commands.
//
// ARCHITECTURE:
// - Runs in VS Code on the host machine (outside containers)
// - Uses `docker logs` commands to monitor container output
// - Uses `docker exec` to create approval files inside containers
// - Monitors containers by name with configurable container selection
//
// RELATIONSHIP TO OTHER FILES:
// - This is an ALTERNATIVE implementation for external monitoring
// - See extension.ts for INTERNAL monitoring approach (primary)
// - This file is NOT used in the current build (package.json → extension.js)
// - Provided as reference implementation and development tool
//
// WHEN TO USE:
// ✓ Monitoring containers from host machine VS Code
// ✓ Development/debugging scenarios
// ✓ Multi-container orchestration environments
// ✓ Centralized monitoring of multiple containers
// ✓ CI/CD pipelines or automated testing
//
// WHEN NOT TO USE:
// ✗ Standard tunnel deployment (use extension.ts instead)
// ✗ When VS Code runs inside the container
// ✗ Single-container production environments
//
// SETUP FOR EXTERNAL MONITORING:
// 1. Copy this file to extension.ts (replacing the internal version)
// 2. Configure containerName in VS Code settings
// 3. Ensure Docker is accessible from host machine
// 4. Recompile and package the extension
//
// For internal monitoring (default), use extension.ts instead.
// ============================================================================

import * as vscode from 'vscode';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface UpdateStatus {
  updateAvailable: boolean;
  installedVersion?: string;
  candidateVersion?: string;
  timestamp: Date;
}

export function activate(context: vscode.ExtensionContext) {
  console.log('VS Code Container Updater extension is now active');

  const updater = new ContainerUpdater(context);
  
  // Register commands
  const checkCommand = vscode.commands.registerCommand('vscode-container-updater.checkUpdates', () => {
    updater.checkForUpdates();
  });

  const approveCommand = vscode.commands.registerCommand('vscode-container-updater.approveUpdate', () => {
    updater.approveUpdate();
  });

  const configureCommand = vscode.commands.registerCommand('vscode-container-updater.configure', () => {
    updater.showConfiguration();
  });

  context.subscriptions.push(checkCommand, approveCommand, configureCommand);

  // Start monitoring if auto-check is enabled
  const config = vscode.workspace.getConfiguration('vscode-container-updater');
  if (config.get('autoCheck', true)) {
    updater.startMonitoring();
  }
}

class ContainerUpdater {
  private context: vscode.ExtensionContext;
  private statusBarItem: vscode.StatusBarItem;
  private monitoringInterval?: NodeJS.Timeout;
  private lastUpdateStatus: UpdateStatus = { updateAvailable: false, timestamp: new Date() };

  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.command = 'vscode-container-updater.checkUpdates';
    this.statusBarItem.text = '$(cloud-download) Container Updates';
    this.statusBarItem.tooltip = 'Check for VS Code container updates';
    this.statusBarItem.show();
    
    context.subscriptions.push(this.statusBarItem);
  }

  startMonitoring() {
    const config = vscode.workspace.getConfiguration('vscode-container-updater');
    const intervalSeconds = config.get('checkInterval', 300); // Default 5 minutes
    
    // Initial check
    this.checkForUpdates();
    
    // Set up periodic checking
    this.monitoringInterval = setInterval(() => {
      this.checkForUpdates();
    }, intervalSeconds * 1000);

    vscode.window.showInformationMessage('Container update monitoring started');
  }

  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }
  }

  async checkForUpdates() {
    try {
      const config = vscode.workspace.getConfiguration('vscode-container-updater');
      const containerName = config.get('containerName', 'vscode-server-tunnel');

      // EXTERNAL MONITORING: Check if target container is running from host machine
      const isRunning = await this.isContainerRunning(containerName);
      if (!isRunning) {
        this.updateStatusBar('Container not running', '$(warning)');
        return;
      }

      // EXTERNAL MONITORING: Get container logs using docker logs command
      const updateStatus = await this.parseContainerLogs(containerName);
      
      if (updateStatus.updateAvailable && !this.lastUpdateStatus.updateAvailable) {
        // New update detected
        this.showUpdateNotification(updateStatus);
      }

      this.lastUpdateStatus = updateStatus;
      this.updateStatusBar(
        updateStatus.updateAvailable ? 'Update Available!' : 'Up to date',
        updateStatus.updateAvailable ? '$(warning)' : '$(check)'
      );

    } catch (error) {
      console.error('Error checking for updates:', error);
      this.updateStatusBar('Check failed', '$(error)');
    }
  }

  private async isContainerRunning(containerName: string): Promise<boolean> {
    try {
      const cmd = 'docker ps --format "{{.Names}}" | grep "^' + containerName + '$"';
      const { stdout } = await execAsync(cmd);
      return stdout.trim() === containerName;
    } catch {
      return false;
    }
  }

  private async parseContainerLogs(containerName: string): Promise<UpdateStatus> {
    try {
      // EXTERNAL MONITORING: Use docker logs to get container output from host
      // This requires Docker CLI access and container to be running
      const cmd = 'docker logs --tail 50 ' + containerName + ' 2>&1';
      const { stdout } = await execAsync(cmd);
      
      // Look for update notification pattern
      const updatePattern = /Update available for VS Code CLI \(installed: ([^,]+), candidate: ([^)]+)\)/;
      const match = stdout.match(updatePattern);
      
      if (match) {
        return {
          updateAvailable: true,
          installedVersion: match[1],
          candidateVersion: match[2],
          timestamp: new Date()
        };
      }

      return { updateAvailable: false, timestamp: new Date() };
    } catch (error) {
      console.error('Error parsing container logs:', error);
      return { updateAvailable: false, timestamp: new Date() };
    }
  }

  private showUpdateNotification(updateStatus: UpdateStatus) {
    const message = 'VS Code CLI update available: ' + updateStatus.installedVersion + ' -> ' + updateStatus.candidateVersion;
    
    vscode.window.showWarningMessage(
      message,
      'Approve Update',
      'Check Later',
      'Stop Monitoring'
    ).then((selection: string | undefined) => {
      switch (selection) {
        case 'Approve Update':
          this.approveUpdate();
          break;
        case 'Stop Monitoring':
          this.stopMonitoring();
          break;
        // 'Check Later' - do nothing
      }
    });
  }

  async approveUpdate() {
    try {
      const config = vscode.workspace.getConfiguration('vscode-container-updater');
      const containerName = config.get('containerName', 'vscode-server-tunnel');

      // EXTERNAL MONITORING: Use docker exec to create approval file inside container
      // This requires Docker CLI access and running container
      const approvalFile = '$HOME/APPROVE_CODE_UPDATE';
      const cmd = 'docker exec ' + containerName + ' bash -c "touch ' + approvalFile + '"';
      await execAsync(cmd);

      vscode.window.showInformationMessage(
        'Update approved! The container will install the update on the next check cycle.',
        'Check Status'
      ).then((selection: string | undefined) => {
        if (selection === 'Check Status') {
          this.checkForUpdates();
        }
      });

    } catch (error) {
      const errorMsg = 'Failed to approve update: ' + String(error);
      vscode.window.showErrorMessage(errorMsg);
    }
  }

  private updateStatusBar(text: string, icon: string) {
    this.statusBarItem.text = icon + ' ' + text;
    this.statusBarItem.tooltip = 'Container Updates: ' + text;
  }

  showConfiguration() {
    vscode.commands.executeCommand('workbench.action.openSettings', 'vscode-container-updater');
  }

  dispose() {
    this.stopMonitoring();
    this.statusBarItem.dispose();
  }
}

export function deactivate() {
  // Cleanup is handled by dispose methods
}
